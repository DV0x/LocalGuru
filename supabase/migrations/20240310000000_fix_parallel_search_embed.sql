-- Migration: Fix parallel_search to remove dependency on OpenAI schema
-- Description: Modifies the parallel_search function to accept a query embedding parameter

-- Drop existing function to recreate it
DROP FUNCTION IF EXISTS public.parallel_search;

-- Create the improved version of the function that accepts a query embedding
CREATE OR REPLACE FUNCTION public.parallel_search(
  search_query TEXT,
  query_embedding VECTOR(1536),
  similarity_threshold_docs DOUBLE PRECISION DEFAULT 0.65,
  similarity_threshold_chunks DOUBLE PRECISION DEFAULT 0.7,
  docs_weight DOUBLE PRECISION DEFAULT 0.8,
  max_results INTEGER DEFAULT 15
)
RETURNS TABLE (
  id TEXT,
  content_type TEXT,
  title TEXT,
  similarity DOUBLE PRECISION,
  text_preview TEXT,
  is_chunk BOOLEAN,
  chunk_index INTEGER,
  parent_title TEXT,
  subreddit TEXT
)
LANGUAGE plpgsql
SECURITY INVOKER
SET search_path = ''
AS $$
BEGIN
  RETURN QUERY
  
  WITH 
  -- Search in document-level embeddings (posts)
  post_results AS (
    SELECT 
      p.id, 
      'post' AS content_type,
      p.title,
      (1 - (p.embedding <=> query_embedding))::DOUBLE PRECISION AS similarity,
      CASE 
        WHEN length(p.content) > 200 THEN substring(p.content, 1, 200) || '...'
        ELSE p.content
      END AS text_preview,
      FALSE AS is_chunk,
      NULL::INTEGER AS chunk_index,
      NULL::TEXT AS parent_title,
      p.subreddit
    FROM public.reddit_posts p
    WHERE 1 - (p.embedding <=> query_embedding) > similarity_threshold_docs
    ORDER BY similarity DESC
    LIMIT 50
  ),
  
  -- Search in document-level embeddings (comments)
  comment_results AS (
    SELECT 
      c.id, 
      'comment' AS content_type,
      NULL AS title,
      (1 - (c.embedding <=> query_embedding))::DOUBLE PRECISION AS similarity,
      CASE 
        WHEN length(c.content) > 200 THEN substring(c.content, 1, 200) || '...'
        ELSE c.content
      END AS text_preview,
      FALSE AS is_chunk,
      NULL::INTEGER AS chunk_index,
      p.title AS parent_title,
      p.subreddit
    FROM public.reddit_comments c
    JOIN public.reddit_posts p ON c.post_id = p.id
    WHERE 1 - (c.embedding <=> query_embedding) > similarity_threshold_docs
    ORDER BY similarity DESC
    LIMIT 50
  ),
  
  -- Search in chunk-level embeddings
  chunk_results AS (
    SELECT 
      c.parent_id AS id,
      c.content_type,
      CASE WHEN c.content_type = 'post' THEN p.title ELSE NULL END AS title,
      c.similarity::DOUBLE PRECISION,
      c.chunk_text AS text_preview,
      TRUE AS is_chunk,
      c.chunk_index,
      CASE 
        WHEN c.content_type = 'comment' THEN p2.title
        ELSE NULL
      END AS parent_title,
      CASE
        WHEN c.content_type = 'post' THEN p.subreddit
        ELSE p2.subreddit
      END AS subreddit
    FROM 
      public.search_content_chunks(query_embedding, similarity_threshold_chunks::FLOAT, 50) c
    LEFT JOIN public.reddit_posts p ON c.content_type = 'post' AND c.parent_id = p.id
    LEFT JOIN public.reddit_comments cm ON c.content_type = 'comment' AND c.parent_id = cm.id
    LEFT JOIN public.reddit_posts p2 ON cm.post_id = p2.id
  )
  
  -- Combine and rank results with weighting
  SELECT * FROM (
    -- Document-level results with weight adjustment
    SELECT 
      id, 
      content_type, 
      title, 
      (similarity * docs_weight)::DOUBLE PRECISION AS similarity, 
      text_preview,
      is_chunk,
      chunk_index,
      parent_title,
      subreddit
    FROM post_results
    
    UNION ALL
    
    SELECT 
      id, 
      content_type, 
      title, 
      (similarity * docs_weight)::DOUBLE PRECISION AS similarity, 
      text_preview,
      is_chunk,
      chunk_index,
      parent_title,
      subreddit
    FROM comment_results
    
    UNION ALL
    
    -- Chunk-level results (already weighted in the function)
    SELECT 
      id, 
      content_type, 
      title, 
      similarity, 
      text_preview,
      is_chunk,
      chunk_index,
      parent_title,
      subreddit
    FROM chunk_results
  ) combined
  ORDER BY similarity DESC
  LIMIT max_results;
END;
$$;

-- Add comments to the function for documentation
COMMENT ON FUNCTION public.parallel_search IS 
'Performs a semantic search across both document-level embeddings (reddit_posts and reddit_comments tables) 
and chunk-level embeddings (content_chunks table), combining the results for comprehensive search results.

Parameters:
- search_query: The text query to search for
- query_embedding: The vector embedding of the search query (must be generated by the client)
- similarity_threshold_docs: Minimum similarity score for document results (default: 0.65)
- similarity_threshold_chunks: Minimum similarity score for chunk results (default: 0.7)
- docs_weight: Weight applied to document-level results (default: 0.8)
- max_results: Maximum number of results to return (default: 15)

Return values:
- id: The ID of the post, comment, or parent of a chunk
- content_type: Either "post" or "comment"
- title: Title of the post (null for comments)
- similarity: The weighted similarity score
- text_preview: Preview of the matching content
- is_chunk: Whether the result is from chunk-level search
- chunk_index: The index of the chunk (null for document results)
- parent_title: For comments, the title of the parent post
- subreddit: The subreddit of the post

Example usage:
SELECT * FROM public.parallel_search(''What is GPT-4?'', embedding_vector, 0.6, 0.65, 0.75, 20);
';

-- Create text-only version for testing with sample data
CREATE OR REPLACE FUNCTION public.text_search(
  search_query TEXT,
  filter_subreddit TEXT DEFAULT NULL,
  max_results INTEGER DEFAULT 15
)
RETURNS TABLE (
  id TEXT,
  content_type TEXT,
  title TEXT,
  relevance DOUBLE PRECISION, 
  text_preview TEXT,
  is_chunk BOOLEAN,
  chunk_index INTEGER,
  parent_title TEXT,
  subreddit TEXT
)
LANGUAGE plpgsql
SECURITY INVOKER
SET search_path = ''
AS $$
BEGIN
  -- Create search configuration for text search
  RETURN QUERY
  
  WITH 
  -- Search in posts
  post_results AS (
    SELECT 
      p.id, 
      'post' AS content_type,
      p.title,
      ts_rank(to_tsvector('english', COALESCE(p.title, '') || ' ' || COALESCE(p.content, '')), 
              plainto_tsquery('english', search_query))::DOUBLE PRECISION AS relevance,
      CASE 
        WHEN length(p.content) > 200 THEN substring(p.content, 1, 200) || '...'
        ELSE p.content
      END AS text_preview,
      FALSE AS is_chunk,
      NULL::INTEGER AS chunk_index,
      NULL::TEXT AS parent_title,
      p.subreddit
    FROM public.reddit_posts p
    WHERE 
      to_tsvector('english', COALESCE(p.title, '') || ' ' || COALESCE(p.content, '')) @@ 
      plainto_tsquery('english', search_query)
      AND (filter_subreddit IS NULL OR p.subreddit = filter_subreddit)
    ORDER BY relevance DESC
    LIMIT 20
  ),
  
  -- Search in comments
  comment_results AS (
    SELECT 
      c.id, 
      'comment' AS content_type,
      NULL AS title,
      ts_rank(to_tsvector('english', c.content), 
              plainto_tsquery('english', search_query))::DOUBLE PRECISION AS relevance,
      CASE 
        WHEN length(c.content) > 200 THEN substring(c.content, 1, 200) || '...'
        ELSE c.content
      END AS text_preview,
      FALSE AS is_chunk,
      NULL::INTEGER AS chunk_index,
      p.title AS parent_title,
      p.subreddit
    FROM public.reddit_comments c
    JOIN public.reddit_posts p ON c.post_id = p.id
    WHERE 
      to_tsvector('english', c.content) @@ plainto_tsquery('english', search_query)
      AND (filter_subreddit IS NULL OR p.subreddit = filter_subreddit)
    ORDER BY relevance DESC
    LIMIT 20
  ),
  
  -- Search in chunks
  chunk_results AS (
    SELECT 
      c.parent_id AS id,
      c.content_type,
      CASE WHEN c.content_type = 'post' THEN p.title ELSE NULL END AS title,
      ts_rank(to_tsvector('english', c.chunk_text), 
              plainto_tsquery('english', search_query))::DOUBLE PRECISION AS relevance,
      c.chunk_text AS text_preview,
      TRUE AS is_chunk,
      c.chunk_index,
      CASE 
        WHEN c.content_type = 'comment' THEN p2.title
        ELSE NULL
      END AS parent_title,
      CASE
        WHEN c.content_type = 'post' THEN p.subreddit
        ELSE p2.subreddit
      END AS subreddit
    FROM public.content_chunks c
    LEFT JOIN public.reddit_posts p ON c.content_type = 'post' AND c.parent_id = p.id
    LEFT JOIN public.reddit_comments cm ON c.content_type = 'comment' AND c.parent_id = cm.id
    LEFT JOIN public.reddit_posts p2 ON cm.post_id = p2.id
    WHERE 
      to_tsvector('english', c.chunk_text) @@ plainto_tsquery('english', search_query)
      AND (filter_subreddit IS NULL OR 
           (c.content_type = 'post' AND p.subreddit = filter_subreddit) OR 
           (c.content_type = 'comment' AND p2.subreddit = filter_subreddit))
    ORDER BY relevance DESC
    LIMIT 20
  )
  
  -- Combine results
  SELECT * FROM (
    SELECT * FROM post_results
    UNION ALL
    SELECT * FROM comment_results
    UNION ALL
    SELECT * FROM chunk_results
  ) combined
  ORDER BY relevance DESC
  LIMIT max_results;
END;
$$;

-- Add comments to the function for documentation
COMMENT ON FUNCTION public.text_search IS 
'Performs a text search across posts, comments, and content chunks using PostgreSQL full-text search.
This function can be used for testing or as a fallback when embeddings are not available.

Parameters:
- search_query: The text query to search for
- filter_subreddit: Optional subreddit to filter results (default: NULL)
- max_results: Maximum number of results to return (default: 15)

Return values use the same structure as parallel_search for compatibility.';

-- Grant access to the functions for authenticated and anonymous users
GRANT EXECUTE ON FUNCTION public.parallel_search TO authenticated, anon;
GRANT EXECUTE ON FUNCTION public.text_search TO authenticated, anon; 